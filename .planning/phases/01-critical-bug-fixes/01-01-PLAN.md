---
phase: 01-critical-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kalasetu-backend/controllers/bookingController.js
  - kalasetu-backend/routes/authRoutes.js
  - kalasetu-backend/routes/userAuthRoutes.js
autonomous: true

must_haves:
  truths:
    - "Concurrent booking requests for the same artisan time slot result in exactly one booking; the second gets 409 Conflict"
    - "Login endpoints allow max 20 attempts per 15 minutes per IP, then return 429"
    - "Register endpoints allow max 5 attempts per hour per IP, then return 429"
    - "Rate limit responses include Retry-After header via standardHeaders"
  artifacts:
    - path: "kalasetu-backend/controllers/bookingController.js"
      provides: "Transaction-wrapped booking creation"
      contains: "startSession|startTransaction|session\\.commitTransaction|session\\.abortTransaction|session\\.endSession"
    - path: "kalasetu-backend/routes/authRoutes.js"
      provides: "Tightened auth rate limiters"
      contains: "max: 20|windowMs: 60 \\* 60 \\* 1000"
    - path: "kalasetu-backend/routes/userAuthRoutes.js"
      provides: "Tightened user auth rate limiters"
      contains: "max: 20|windowMs: 60 \\* 60 \\* 1000"
  key_links:
    - from: "kalasetu-backend/controllers/bookingController.js"
      to: "MongoDB"
      via: "Mongoose session transaction"
      pattern: "\\.session\\(session\\)"
    - from: "kalasetu-backend/routes/authRoutes.js"
      to: "express-rate-limit"
      via: "rateLimit middleware on login/register routes"
      pattern: "loginLimiter|registerLimiter"
---

<objective>
Fix the booking race condition (BUG-01) and tighten auth rate limiting (BUG-04).

Purpose: Prevent duplicate bookings from concurrent requests and protect auth endpoints from brute-force attacks. These are the two highest-priority backend security/reliability fixes.

Output: Transaction-wrapped booking creation in bookingController.js, updated rate limiters in authRoutes.js and userAuthRoutes.js.
</objective>

<execution_context>
@C:/Users/Lenovo/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Lenovo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-bug-fixes/01-RESEARCH.md

@kalasetu-backend/controllers/bookingController.js
@kalasetu-backend/routes/authRoutes.js
@kalasetu-backend/routes/userAuthRoutes.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap booking creation in MongoDB transaction (BUG-01)</name>
  <files>kalasetu-backend/controllers/bookingController.js</files>
  <action>
In `createBooking` function (lines 65-88), wrap the overlap check + booking creation in a MongoDB transaction:

1. Add `import mongoose from 'mongoose';` at the top of the file (after existing imports).

2. Replace lines 65-88 (from `// Check for overlapping bookings` through `res.status(201).json(...)`) with transaction-wrapped code:

```javascript
// Check for overlapping bookings within a transaction to prevent race conditions
const session = await mongoose.startSession();
session.startTransaction();

try {
  const overlap = await Booking.findOne({
    artisan: artisanId,
    status: { $in: ['pending', 'confirmed'] },
    start: { $lt: endTime },
    end: { $gt: startTime },
  }).session(session);

  if (overlap) {
    await session.abortTransaction();
    return res.status(409).json({ success: false, message: 'This time slot is already booked' });
  }

  const finalPrice = price ?? service?.price ?? 0;

  // .create() requires array syntax when using sessions
  const [booking] = await Booking.create([{
    artisan: artisanId,
    user: userId,
    service: service?._id,
    serviceName,
    categoryName,
    start: startTime,
    end: endTime,
    notes: notes || '',
    price: finalPrice,
  }], { session });

  await session.commitTransaction();
  res.status(201).json({ success: true, data: booking });
} catch (err) {
  await session.abortTransaction();
  throw err; // asyncHandler catches and passes to errorMiddleware
} finally {
  session.endSession(); // CRITICAL: prevent connection leaks
}
```

Key details:
- `.session(session)` MUST be on the `findOne` query so it reads within the transaction.
- `Booking.create()` uses array syntax `[{...}]` when passing `{ session }` option (Mongoose 8.x requirement).
- `session.endSession()` in `finally` block prevents connection pool leaks.
- The `finalPrice` calculation moves inside the transaction block (it was between the overlap check and create).
- If `abortTransaction()` itself throws (e.g., network error), the `finally` block still calls `endSession()`.
  </action>
  <verify>
1. Read the modified file and confirm:
   - `import mongoose from 'mongoose'` is present
   - `startSession()` and `startTransaction()` are called
   - `.session(session)` is chained on `findOne`
   - `.create()` uses array syntax with `{ session }`
   - `commitTransaction()` is called on success
   - `abortTransaction()` is called on overlap and in catch
   - `endSession()` is called in finally block
2. Run `node -c kalasetu-backend/controllers/bookingController.js` to verify syntax.
  </verify>
  <done>
The `createBooking` function uses a MongoDB transaction to atomically check for overlapping bookings and create the new booking. Concurrent requests for the same time slot result in exactly one booking; the loser gets 409 Conflict. No connection leaks due to finally block.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tighten auth rate limiting on both route files (BUG-04)</name>
  <files>kalasetu-backend/routes/authRoutes.js, kalasetu-backend/routes/userAuthRoutes.js</files>
  <action>
Update rate limiters in BOTH `authRoutes.js` and `userAuthRoutes.js` to match the BUG-04 specification:

**In authRoutes.js:**

1. Rename `strictLimiter` to `loginLimiter` for clarity. Update its config:
   - `windowMs: 15 * 60 * 1000` (keep 15 minutes)
   - `max: 20` (increase from 15 to 20)
   - Add `message: { success: false, message: 'Too many login attempts. Please try again in 15 minutes.' }`

2. Update `registerLimiter`:
   - `windowMs: 60 * 60 * 1000` (increase from 15 minutes to 1 hour)
   - `max: 5` (keep at 5)
   - Update message: `{ success: false, message: 'Too many registration attempts. Please try again in 1 hour.' }`

3. Update route references: replace `strictLimiter` with `loginLimiter` on login, forgot-password, reset-password routes.

4. Add `loginLimiter` to the `firebase-login` route (currently has no rate limiter).

**In userAuthRoutes.js:**

Apply the same changes:

1. Rename `strictLimiter` to `loginLimiter`. Update config:
   - `max: 20` (from 15)
   - Add `message: { success: false, message: 'Too many login attempts. Please try again in 15 minutes.' }`

2. Update `registerLimiter`:
   - `windowMs: 60 * 60 * 1000` (from 15 minutes to 1 hour)
   - Update message: `{ success: false, message: 'Too many registration attempts. Please try again in 1 hour.' }`

3. Update route references: replace `strictLimiter` with `loginLimiter`.

4. Remove `strictLimiter` from the `/logout` route (logout should not be rate-limited â€” it prevents users from logging out under rate limit).

Both files must follow the `{ success: false, message: '...' }` response format used throughout the codebase.
  </action>
  <verify>
1. Read both modified files and confirm:
   - `loginLimiter` has `max: 20`, `windowMs: 15 * 60 * 1000`
   - `registerLimiter` has `max: 5`, `windowMs: 60 * 60 * 1000`
   - Both have `standardHeaders: true` and `legacyHeaders: false`
   - Messages follow `{ success: false, message: '...' }` pattern
   - No `strictLimiter` references remain
   - `firebase-login` route has `loginLimiter` in authRoutes.js
   - Logout route in userAuthRoutes.js has no rate limiter
2. Run `node -c kalasetu-backend/routes/authRoutes.js && node -c kalasetu-backend/routes/userAuthRoutes.js` to verify syntax.
  </verify>
  <done>
Login endpoints rate-limited to 20 requests per 15 minutes per IP. Register endpoints rate-limited to 5 requests per hour per IP. Both return 429 with `Retry-After` header (via `standardHeaders: true`) and consistent error format. Firebase login and password reset endpoints also rate-limited.
  </done>
</task>

</tasks>

<verification>
1. Syntax check all modified files: `node -c kalasetu-backend/controllers/bookingController.js && node -c kalasetu-backend/routes/authRoutes.js && node -c kalasetu-backend/routes/userAuthRoutes.js`
2. Verify no `strictLimiter` references remain in either route file.
3. Verify `session` keyword appears in bookingController.js createBooking function.
4. Verify `mongoose` import exists in bookingController.js.
</verification>

<success_criteria>
- bookingController.js uses MongoDB transaction (startSession, startTransaction, commitTransaction, abortTransaction, endSession) wrapping the overlap check and booking creation.
- authRoutes.js login limiter allows 20/15min, register limiter allows 5/60min.
- userAuthRoutes.js login limiter allows 20/15min, register limiter allows 5/60min.
- All rate limit responses use `{ success: false, message: '...' }` format.
- All files pass syntax check.
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-bug-fixes/01-01-SUMMARY.md`
</output>
