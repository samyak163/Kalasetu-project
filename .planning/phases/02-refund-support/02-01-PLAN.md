---
phase: 02-refund-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kalasetu-backend/models/refundRequestModel.js
  - kalasetu-backend/controllers/refundController.js
  - kalasetu-backend/routes/refundRoutes.js
  - kalasetu-backend/controllers/paymentController.js
  - kalasetu-backend/controllers/adminDashboardController.js
  - kalasetu-backend/routes/adminRoutes.js
  - kalasetu-backend/server.js
  - kalasetu-backend/utils/email.js
autonomous: true

must_haves:
  truths:
    - "User can request a refund for a captured payment"
    - "Admin can view all refund requests in a filterable list"
    - "Admin can approve or reject a refund request"
    - "Approved refund triggers Razorpay API call and sets status to processing"
    - "Razorpay webhook updates refund status to processed or failed"
    - "Both parties receive email notification on refund status changes"
    - "Cumulative refund validation prevents refunding more than payment amount"
  artifacts:
    - path: "kalasetu-backend/models/refundRequestModel.js"
      provides: "RefundRequest Mongoose schema"
      contains: "model RefundRequest"
    - path: "kalasetu-backend/controllers/refundController.js"
      provides: "User-facing refund request creation and listing"
      exports: ["createRefundRequest", "getUserRefundRequests", "getRefundRequestById"]
    - path: "kalasetu-backend/routes/refundRoutes.js"
      provides: "REST endpoints for /api/refunds"
      exports: ["default"]
    - path: "kalasetu-backend/controllers/adminDashboardController.js"
      provides: "Admin refund management endpoints"
      exports: ["getAllRefundRequests", "getRefundRequestsStats", "approveRefundRequest", "rejectRefundRequest"]
  key_links:
    - from: "kalasetu-backend/controllers/refundController.js"
      to: "kalasetu-backend/models/refundRequestModel.js"
      via: "Mongoose CRUD"
      pattern: "RefundRequest\\.(create|find|findById)"
    - from: "kalasetu-backend/controllers/adminDashboardController.js"
      to: "kalasetu-backend/utils/razorpay.js"
      via: "refundPayment call on approval"
      pattern: "refundPayment"
    - from: "kalasetu-backend/controllers/paymentController.js"
      to: "kalasetu-backend/models/refundRequestModel.js"
      via: "webhook handler updates RefundRequest status"
      pattern: "RefundRequest\\.findOne.*razorpayRefundId"
    - from: "kalasetu-backend/controllers/refundController.js"
      to: "kalasetu-backend/utils/email.js"
      via: "email notifications on status change"
      pattern: "sendEmail|sendNotificationEmail"
---

<objective>
Build the complete refund request backend: data model, user-facing API, admin management API, Razorpay webhook integration, and email notifications.

Purpose: Enables users to request refunds for captured payments with admin oversight, preventing refund abuse while providing customer recourse. This is the STUB-01 requirement from the roadmap.

Output: RefundRequest model, user refund endpoints, admin refund endpoints, webhook handlers for refund.processed/failed events, email notifications.
</objective>

<execution_context>
@C:/Users/Lenovo/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Lenovo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-refund-support/02-RESEARCH.md
@kalasetu-backend/models/paymentModel.js
@kalasetu-backend/controllers/paymentController.js
@kalasetu-backend/routes/adminRoutes.js
@kalasetu-backend/utils/razorpay.js
@kalasetu-backend/utils/email.js
@kalasetu-backend/utils/onesignal.js
@kalasetu-backend/models/notificationModel.js
@kalasetu-backend/server.js
@kalasetu-backend/middleware/authMiddleware.js
@kalasetu-backend/controllers/adminDashboardController.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: RefundRequest model + user-facing controller + routes</name>
  <files>
    kalasetu-backend/models/refundRequestModel.js
    kalasetu-backend/controllers/refundController.js
    kalasetu-backend/routes/refundRoutes.js
    kalasetu-backend/server.js
  </files>
  <action>
**1. Create `kalasetu-backend/models/refundRequestModel.js`:**

Create the RefundRequest Mongoose schema following the pattern from 02-RESEARCH.md:

```javascript
import mongoose from 'mongoose';

const refundRequestSchema = new mongoose.Schema({
  payment: { type: mongoose.Schema.Types.ObjectId, ref: 'Payment', required: true, index: true },
  booking: { type: mongoose.Schema.Types.ObjectId, ref: 'Booking', index: true },
  requestedBy: { type: mongoose.Schema.Types.ObjectId, required: true, refPath: 'requestedByModel' },
  requestedByModel: { type: String, required: true, enum: ['User', 'Artisan'] },
  amount: { type: Number, required: true, min: 0 },
  reason: { type: String, required: true, maxlength: 1000 },
  evidence: [{
    type: { type: String, enum: ['image', 'document', 'text'] },
    url: String,
    description: String
  }],
  status: {
    type: String,
    enum: ['pending', 'approved', 'rejected', 'processing', 'processed', 'failed'],
    default: 'pending',
    index: true
  },
  adminResponse: {
    adminId: { type: mongoose.Schema.Types.ObjectId, ref: 'Admin' },
    action: { type: String, enum: ['approved', 'rejected'] },
    reason: String,
    respondedAt: Date
  },
  razorpayRefundId: String,
  razorpayRefundStatus: String,
  processedAt: Date,
  failureReason: String
}, { timestamps: true });
```

Add compound indexes: `{ status: 1, createdAt: -1 }`, `{ payment: 1, status: 1 }`, `{ requestedBy: 1, createdAt: -1 }`.

Export as default `mongoose.model('RefundRequest', refundRequestSchema)`.

**2. Create `kalasetu-backend/controllers/refundController.js`:**

All handlers use `asyncHandler` wrapper from `../utils/asyncHandler.js`. Use Zod for validation.

- `createRefundRequest`: POST handler. Accepts `{ paymentId, amount, reason, evidence }`.
  - Validate with Zod schema: paymentId is 24-char hex string, amount > 0, reason min 10 chars max 1000.
  - Fetch Payment by paymentId. Return 404 if not found.
  - Check `req.user._id` matches `payment.payerId` (only payer can request refund). Return 403 otherwise.
  - Check `payment.status === 'captured'`. Return 400 otherwise with "Only captured payments can be refunded".
  - **Cumulative refund check**: Query `RefundRequest.find({ payment: paymentId, status: { $in: ['pending', 'approved', 'processing', 'processed'] } })`. Sum their amounts. If `requestedAmount + totalExisting > payment.amount`, return 400 "Refund amount exceeds available balance".
  - Create RefundRequest with `requestedBy: req.user._id`, `requestedByModel: req.accountType === 'artisan' ? 'Artisan' : 'User'`.
  - Create in-app Notification (using Notification model) for user confirming submission.
  - Return 201 with the created refund request.

- `getUserRefundRequests`: GET handler. List user's refund requests.
  - Query by `requestedBy: req.user._id`. Support `?status=` filter and `?page=&limit=` pagination (default limit 20).
  - Populate `payment` (select: amount, purpose, razorpayPaymentId, status).
  - Sort by `createdAt: -1`. Return with pagination object.

- `getRefundRequestById`: GET handler. Single refund request detail.
  - Find by `_id` param. Populate payment and booking.
  - Verify `requestedBy` matches `req.user._id`. Return 403 if not.
  - Return refund request.

Export all three as named exports plus a default object.

**3. Create `kalasetu-backend/routes/refundRoutes.js`:**

```javascript
import express from 'express';
import { protectAny } from '../middleware/authMiddleware.js';
import { createRefundRequest, getUserRefundRequests, getRefundRequestById } from '../controllers/refundController.js';
const router = express.Router();

router.post('/', protectAny, createRefundRequest);
router.get('/', protectAny, getUserRefundRequests);
router.get('/:id', protectAny, getRefundRequestById);

export default router;
```

**4. Mount in `kalasetu-backend/server.js`:**

Add `import refundRoutes from './routes/refundRoutes.js';` near the other route imports.
Add `app.use('/api/refunds', refundRoutes);` near the other route mounts (after paymentRoutes).
  </action>
  <verify>
Run `node -e "import('./kalasetu-backend/models/refundRequestModel.js').then(m => console.log('Model loaded:', !!m.default))"` from project root to verify model loads without syntax errors.

Check that `kalasetu-backend/server.js` contains the refundRoutes import and mount.

Verify refundController.js exports: `node -e "import('./kalasetu-backend/controllers/refundController.js').then(m => console.log('Exports:', Object.keys(m)))"`.
  </verify>
  <done>
RefundRequest model defined with all fields and indexes. User-facing endpoints (POST /, GET /, GET /:id) implemented with Zod validation, cumulative refund check, authorization, and pagination. Routes mounted at /api/refunds in server.js.
  </done>
</task>

<task type="auto">
  <name>Task 2: Admin refund endpoints + webhook handler + email notifications</name>
  <files>
    kalasetu-backend/controllers/adminDashboardController.js
    kalasetu-backend/routes/adminRoutes.js
    kalasetu-backend/controllers/paymentController.js
    kalasetu-backend/utils/email.js
  </files>
  <action>
**1. Add admin refund functions to `kalasetu-backend/controllers/adminDashboardController.js`:**

Import RefundRequest model at top: `import RefundRequest from '../models/refundRequestModel.js';`
Import `{ refundPayment }` from `'../utils/razorpay.js'`.
Import `{ sendEmail }` from `'../utils/email.js'`.
Import `{ sendNotificationToUser }` from `'../utils/onesignal.js'`.
Import `Notification` from `'../models/notificationModel.js'`.

Add four new exported functions:

- `getAllRefundRequests`: GET handler with pagination, status filter, date range, search.
  - Accept query params: `{ page = 1, limit = 20, status = 'all', startDate, endDate, search }`.
  - Build query object. If status !== 'all', add to query. Add date range if provided.
  - If search provided, use `escapeRegex(search)` (already defined in this file) to search by matching Payment's razorpayPaymentId or razorpayOrderId (find matching payment IDs first, then filter RefundRequests by those payment IDs -- same pattern as research example).
  - Populate: `payment` (select: amount, razorpayPaymentId, razorpayOrderId, status, purpose), `requestedBy` (select: fullName, email, profileImageUrl), `adminResponse.adminId` (select: fullName, email).
  - Sort by `createdAt: -1`. Apply limit and skip for pagination.
  - Count total documents. Return `{ success: true, data: refunds, pagination: { total, page, pages } }`.

- `getRefundRequestsStats`: GET handler. Aggregate counts by status.
  - Use `RefundRequest.aggregate` with `$group` by status to get counts.
  - Also get total amount pending/processing/processed.
  - Return stats object: `{ total, pending, approved, processing, processed, rejected, failed, totalPendingAmount, totalProcessedAmount }`.

- `approveRefundRequest`: POST handler for `/admin/refunds/:id/approve`.
  - Find RefundRequest by id. Return 404 if not found.
  - Check `status === 'pending'`. Return 400 if not pending ("Can only approve pending requests").
  - Set `adminResponse`: `{ adminId: req.user._id, action: 'approved', reason: req.body.reason || 'Approved by admin', respondedAt: new Date() }`.
  - Set `status = 'processing'` (NOT 'approved' -- we skip to processing since we immediately call Razorpay).
  - Look up the Payment to get `razorpayPaymentId`.
  - Call `refundPayment(payment.razorpayPaymentId, refundRequest.amount)` in try/catch.
  - On success: store `razorpayRefundId = refund.id`, `razorpayRefundStatus = refund.status`. Save.
  - On failure: set `status = 'failed'`, `failureReason = error.message`. Save. Return 500 with error.
  - Send notification to user (email + in-app + push -- all wrapped in try/catch, non-blocking):
    - Email via `sendEmail` with HTML template for refund approved/processing.
    - In-app via `Notification.create({ ownerId, ownerType, title: 'Refund Approved', text, url })`.
    - Push via `sendNotificationToUser` (try/catch, don't throw).
  - Return 200 with updated refund request.

- `rejectRefundRequest`: POST handler for `/admin/refunds/:id/reject`.
  - Find RefundRequest by id. Return 404 if not found.
  - Check `status === 'pending'`. Return 400 if not pending.
  - Require `req.body.reason` (admin must give rejection reason). Return 400 if empty.
  - Set `adminResponse`: `{ adminId: req.user._id, action: 'rejected', reason: req.body.reason, respondedAt: new Date() }`.
  - Set `status = 'rejected'`. Save.
  - Send notification to user (email + in-app + push, all try/catch non-blocking).
  - Return 200 with updated refund request.

**2. Add admin refund routes to `kalasetu-backend/routes/adminRoutes.js`:**

Import the four new functions from adminDashboardController.js.
Add these routes after the existing payments routes:

```javascript
router.get('/refunds', protectAdmin, checkPermission('payments', 'view'), getAllRefundRequests);
router.get('/refunds/stats', protectAdmin, checkPermission('payments', 'view'), getRefundRequestsStats);
router.post('/refunds/:id/approve', protectAdmin, checkPermission('payments', 'refund'), approveRefundRequest);
router.post('/refunds/:id/reject', protectAdmin, checkPermission('payments', 'refund'), rejectRefundRequest);
```

Note: Reuse existing 'payments' permission resource since refunds are payment-related. No need to add new permission types.

**3. Update webhook handler in `kalasetu-backend/controllers/paymentController.js`:**

Import RefundRequest at top: `import RefundRequest from '../models/refundRequestModel.js';`
Import `Notification` from `'../models/notificationModel.js'`.
Import `{ sendEmail }` from `'../utils/email.js'`.

In the `handleWebhook` function's switch statement, update the existing cases:

- Change `case 'refund.created':` to handle RefundRequest lookup. The existing `handleRefundCreated` currently only updates Payment. Update it to also find and update the corresponding RefundRequest:
  ```javascript
  async function handleRefundCreated(refundData) {
    // Existing Payment update logic (keep as-is)
    const payment = await Payment.findOne({ razorpayPaymentId: refundData.payment_id });
    if (payment) {
      payment.status = 'refunded';
      payment.refundId = refundData.id;
      payment.refundAmount = refundData.amount / 100;
      payment.refundedAt = new Date();
      await payment.save();
    }

    // NEW: Update RefundRequest status
    const refundRequest = await RefundRequest.findOne({ razorpayRefundId: refundData.id });
    if (refundRequest && refundRequest.status !== 'processed') {
      refundRequest.status = 'processed';
      refundRequest.razorpayRefundStatus = refundData.status;
      refundRequest.processedAt = new Date();
      await refundRequest.save();

      // Notify user that refund is complete
      try {
        const requester = await (refundRequest.requestedByModel === 'User'
          ? import('../models/userModel.js').then(m => m.default.findById(refundRequest.requestedBy).lean())
          : import('../models/artisanModel.js').then(m => m.default.findById(refundRequest.requestedBy).lean()));
        if (requester) {
          await Notification.create({
            ownerId: refundRequest.requestedBy,
            ownerType: refundRequest.requestedByModel === 'User' ? 'user' : 'artisan',
            title: 'Refund Processed',
            text: `Your refund of Rs.${refundRequest.amount} has been processed successfully.`,
            url: `/refunds/${refundRequest._id}`,
            read: false
          });
          await sendEmail({
            to: requester.email,
            subject: 'Your Refund Has Been Processed - KalaSetu',
            html: buildRefundProcessedEmailHTML(requester.fullName, refundRequest)
          }).catch(() => {});
        }
      } catch (notifError) {
        // Non-critical: don't fail webhook for notification errors
      }
    }
  }
  ```

- Add a new case `'refund.failed'` in the switch:
  ```javascript
  case 'refund.failed':
    await handleRefundFailed(req.body.payload?.refund?.entity || paymentData);
    break;
  ```
  Create `handleRefundFailed` function:
  ```javascript
  async function handleRefundFailed(refundData) {
    const refundRequest = await RefundRequest.findOne({ razorpayRefundId: refundData.id });
    if (refundRequest) {
      refundRequest.status = 'failed';
      refundRequest.failureReason = refundData.error_description || 'Refund failed';
      refundRequest.razorpayRefundStatus = refundData.status;
      await refundRequest.save();
      // Notify user (try/catch, non-critical)
    }
  }
  ```

**4. Add refund email template helpers to `kalasetu-backend/utils/email.js`:**

Add two new exported functions after the existing email functions:

- `sendRefundStatusEmail(to, userName, refundRequest, newStatus)`:
  Build HTML email using the existing email pattern (same styles as sendWelcomeEmail etc.). Use brand color `#A55233` for the header background. Include:
  - Status-specific header colors: approved = #4caf50, rejected = #f44336, processed = #A55233, failed = #f44336
  - Refund amount formatted with `toLocaleString('en-IN')`
  - Reason (admin's response reason for reject; refund request reason for others)
  - CTA button linking to `${EMAIL_CONFIG.appUrl}/refunds/${refundRequest._id}`
  - Use `process.env.FRONTEND_URL || EMAIL_CONFIG.appUrl || 'https://kalasetu.com'` for URL.

Also add a helper `buildRefundProcessedEmailHTML(userName, refundRequest)` that returns just the HTML string (used by webhook handler which calls sendEmail directly).

Add these to the default export object at the bottom.
  </action>
  <verify>
Verify adminDashboardController.js exports the four new functions:
`node -e "import('./kalasetu-backend/controllers/adminDashboardController.js').then(m => { const needed = ['getAllRefundRequests','getRefundRequestsStats','approveRefundRequest','rejectRefundRequest']; const found = needed.filter(n => typeof m[n] === 'function'); console.log('Found', found.length, 'of', needed.length); })"`

Verify adminRoutes.js contains the new refund routes by checking the file includes `/refunds`.

Verify paymentController.js imports RefundRequest model.

Verify email.js exports sendRefundStatusEmail.
  </verify>
  <done>
Admin can list, filter, and search refund requests via GET /api/admin/refunds. Admin can view stats via GET /api/admin/refunds/stats. Admin can approve (POST /api/admin/refunds/:id/approve) which triggers Razorpay API and sets status to processing. Admin can reject (POST /api/admin/refunds/:id/reject) with mandatory reason. Webhook handler updates RefundRequest to processed/failed on Razorpay events. Email notifications sent on all status changes (approved, rejected, processed, failed). All notification sends are wrapped in try/catch to prevent blocking the critical path.
  </done>
</task>

</tasks>

<verification>
1. RefundRequest model loads without errors and has correct indexes
2. User endpoints (POST/GET /api/refunds) are mounted and accessible
3. Admin endpoints (GET /api/admin/refunds, GET /api/admin/refunds/stats, POST /api/admin/refunds/:id/approve, POST /api/admin/refunds/:id/reject) are mounted
4. Cumulative refund validation prevents over-refunding
5. Webhook handler processes refund.created and refund.failed events, updating RefundRequest status
6. Email templates generate valid HTML
7. All notification sends are wrapped in try/catch (non-blocking)
8. server.js starts without import errors
</verification>

<success_criteria>
- RefundRequest model exists with all schema fields and indexes from research
- User can create a refund request for a captured payment via POST /api/refunds
- Cumulative refund check prevents requesting more than payment amount
- Admin can list, approve, and reject refund requests
- Approval triggers Razorpay refundPayment API call
- Webhook events update RefundRequest status (processed or failed)
- Email sent on: request submitted, approved/processing, rejected, processed, failed
- In-app notifications created for all status changes
- No new dependencies needed (all libraries already installed)
</success_criteria>

<output>
After completion, create `.planning/phases/02-refund-support/02-01-SUMMARY.md`
</output>
